import { useCallback, useState } from 'react';
import { toast } from 'react-toastify';
import { useAccount, useConnect, useDisconnect, useReadContract, useWriteContract } from 'wagmi';
import { ethers } from 'ethers';
import CONTRACT_ADDRESSES from './contracts';

// Import your contract ABIs (after deployment generates these files)
// We're defining stub interfaces since the real ones will be generated by the deploy script
interface TourBookingABI {
  getFunction: (name: string) => any;
  bookTour: (tourId: number, date: number, participants: number, paymentMethod: number) => Promise<any>;
  getTourBooking: (bookingId: number) => Promise<any>;
}

interface TourOfferingsABI {
  getFunction: (name: string) => any;
  getTour: (tourId: number) => Promise<any>;
  getAllTours: () => Promise<any>;
  createTour: (name: string, description: string, price: number, maxParticipants: number) => Promise<any>;
}

interface PaymentProcessorABI {
  getFunction: (name: string) => any;
  processPayment: (bookingId: number, amount: string, cryptoType?: number) => Promise<any>;
  getPaymentStatus: (bookingId: number) => Promise<any>;
}

// This hook will be populated with real functionality after contract deployment
export function useKidsHubContracts() {
  const { address, isConnected } = useAccount();
  const { disconnectAsync } = useDisconnect();
  const { writeContractAsync } = useWriteContract();
  const [isLoading, setIsLoading] = useState(false);

  // Book a tour using the TourBooking contract
  const bookTour = useCallback(async (
    tourId: number,
    date: number,
    participants: number,
    paymentMethod: number
  ) => {
    if (!isConnected || !address) {
      toast.error('Please connect your wallet first');
      return null;
    }

    setIsLoading(true);
    try {
      // This will be replaced with actual contract call after deployment
      const result = await writeContractAsync({
        address: CONTRACT_ADDRESSES.tourBooking as `0x${string}`,
        abi: [] as any, // This will be populated from the JSON file after deployment
        functionName: 'bookTour',
        args: [tourId, date, participants, paymentMethod],
        account: address,
        chain: undefined // Will be determined by the connected wallet
      });
      
      toast.success('Tour booked successfully!');
      return result;
    } catch (error: any) {
      console.error('Error booking tour:', error);
      toast.error(error?.message || 'Failed to book tour');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [address, isConnected, writeContractAsync]);

  // Get available tours
  const getTours = useCallback(async () => {
    setIsLoading(true);
    try {
      // After deployment, this will use useReadContract to get tours from blockchain
      // For now, we'll return dummy data
      return [
        { id: 1, name: 'Historical Sites Tour', description: 'Explore ancient Tongan landmarks', price: ethers.parseEther('0.1'), maxParticipants: 20 },
        { id: 2, name: 'Village Experience', description: 'Immerse yourself in traditional Tongan village life', price: ethers.parseEther('0.08'), maxParticipants: 15 },
        { id: 3, name: 'Culinary Adventure', description: 'Learn to prepare traditional Tongan dishes', price: ethers.parseEther('0.12'), maxParticipants: 12 }
      ];
    } catch (error) {
      console.error('Error fetching tours:', error);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Process a payment
  const processPayment = useCallback(async (bookingId: number, amount: string, cryptoType: number = 0) => {
    if (!isConnected || !address) {
      toast.error('Please connect your wallet first');
      return null;
    }

    setIsLoading(true);
    try {
      // Determine which contract to use based on crypto type
      // 0 = ETH, 1 = BTC
      const contractAddress = cryptoType === 0 ? 
        CONTRACT_ADDRESSES.paymentProcessor : 
        CONTRACT_ADDRESSES.rbtcPaymentProcessor; 
        
      // This will be replaced with actual contract call after deployment
      const result = await writeContractAsync({
        address: contractAddress as `0x${string}`,
        abi: [] as any, // Will be populated from JSON after deployment
        functionName: 'processPayment',
        args: [bookingId, cryptoType],
        value: ethers.parseEther(amount),
        account: address,
        chain: undefined // Will be determined by the connected wallet
      });
      
      toast.success('Payment processed successfully!');
      return result;
    } catch (error: any) {
      console.error('Error processing payment:', error);
      toast.error(error?.message || 'Failed to process payment');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [address, isConnected, writeContractAsync]);

  return {
    address,
    isConnected,
    isLoading,
    bookTour,
    getTours,
    processPayment,
    disconnect: disconnectAsync,
  };
}

// After contract deployment, this hook will be able to use the generated files
